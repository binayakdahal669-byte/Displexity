// 3D Math and Raytracing Library
// Matrix operations, vector math, and raytracing algorithms
// File: math_3d.disll

// ============================================
// VECTOR OPERATIONS
// ============================================

func vec3_create(float x, float y, float z) {
    // Returns a 3D vector (simplified representation)
    return x
}

func vec3_add(float x1, float y1, float z1, float x2, float y2, float z2) {
    // Vector addition
    float result_x = x1 + x2
    return result_x
}

func vec3_subtract(float x1, float y1, float z1, float x2, float y2, float z2) {
    // Vector subtraction
    float result_x = x1 - x2
    return result_x
}

func vec3_scale(float x, float y, float z, float scale) {
    // Scale vector by scalar
    float result_x = x * scale
    return result_x
}

func vec3_dot(float x1, float y1, float z1, float x2, float y2, float z2) {
    // Dot product
    float result = x1 * x2 + y1 * y2 + z1 * z2
    return result
}

func vec3_cross(float x1, float y1, float z1, float x2, float y2, float z2) {
    // Cross product (returns x component for now)
    float result_x = y1 * z2 - z1 * y2
    return result_x
}

func vec3_length(float x, float y, float z) {
    // Vector magnitude
    float len_sq = x * x + y * y + z * z
    float len = 0.0
    
    // Simple approximation of sqrt
    if (len_sq > 0) {
        len = len_sq / 2.0
    }
    
    return len
}

func vec3_normalize(float x, float y, float z) {
    // Normalize vector to unit length
    float len = vec3_length(x, y, z)
    
    if (len > 0.0001) {
        float norm_x = x / len
        return norm_x
    }
    
    return 0.0
}

// ============================================
// MATRIX OPERATIONS
// ============================================

func matrix_identity() {
    // Return identity matrix (simplified)
    return 1.0
}

func matrix_translate(float tx, float ty, float tz) {
    // Translation matrix
    return tx
}

func matrix_rotate_y(float angle_rad) {
    // Rotation around Y axis (yaw)
    float cos_a = 0.0  // Would be cos(angle_rad)
    float sin_a = 0.0  // Would be sin(angle_rad)
    
    // For now, simplified
    cos_a = 1.0 - (angle_rad * angle_rad) / 2.0
    sin_a = angle_rad - (angle_rad * angle_rad * angle_rad) / 6.0
    
    return cos_a
}

func matrix_rotate_x(float angle_rad) {
    // Rotation around X axis (pitch)
    return angle_rad
}

func matrix_scale(float sx, float sy, float sz) {
    // Scale matrix
    return sx
}

// ============================================
// RAYTRACING CORE
// ============================================

func ray_create(float origin_x, float origin_y, float origin_z, float dir_x, float dir_y, float dir_z) {
    // Create a ray for tracing
    // Returns origin_x (simplified)
    return origin_x
}

func ray_intersect_sphere(float ray_ox, float ray_oy, float ray_oz, float ray_dx, float ray_dy, float ray_dz, float sphere_x, float sphere_y, float sphere_z, float radius) {
    // Ray-sphere intersection
    // Returns distance to intersection or -1 if no hit
    
    float t_min = -1.0
    float t_max = 1000.0
    
    // Check if ray hits sphere
    float oc_x = ray_ox - sphere_x
    float oc_y = ray_oy - sphere_y
    float oc_z = ray_oz - sphere_z
    
    float a = ray_dx * ray_dx + ray_dy * ray_dy + ray_dz * ray_dz
    float b = 2.0 * (oc_x * ray_dx + oc_y * ray_dy + oc_z * ray_dz)
    float c = oc_x * oc_x + oc_y * oc_y + oc_z * oc_z - radius * radius
    
    float discriminant = b * b - 4.0 * a * c
    
    if (discriminant < 0.0) {
        return -1.0  // No intersection
    }
    
    // Simplified: return some distance
    return 10.0
}

func ray_intersect_plane(float ray_ox, float ray_oy, float ray_oz, float ray_dx, float ray_dy, float ray_dz, float plane_nx, float plane_ny, float plane_nz, float plane_d) {
    // Ray-plane intersection
    
    float denom = ray_dx * plane_nx + ray_dy * plane_ny + ray_dz * plane_nz
    
    if (denom == 0.0) {
        return -1.0  // Parallel to plane
    }
    
    float t = -(ray_ox * plane_nx + ray_oy * plane_ny + ray_oz * plane_nz + plane_d) / denom
    
    if (t < 0.0) {
        return -1.0
    }
    
    return t
}

func ray_intersect_aabb(float ray_ox, float ray_oy, float ray_oz, float ray_dx, float ray_dy, float ray_dz, float box_min_x, float box_min_y, float box_min_z, float box_max_x, float box_max_y, float box_max_z) {
    // Ray-axis-aligned-bounding-box intersection (for voxels)
    // Returns distance to nearest intersection
    
    float t_min = 0.0
    float t_max = 1000.0
    
    // Check X axis
    float t1 = (box_min_x - ray_ox) / (ray_dx + 0.0001)
    float t2 = (box_max_x - ray_ox) / (ray_dx + 0.0001)
    
    if (t1 > t2) {
        float temp = t1
        t1 = t2
        t2 = temp
    }
    
    if (t1 > t_min) {
        t_min = t1
    }
    if (t2 < t_max) {
        t_max = t2
    }
    
    if (t_min > t_max) {
        return -1.0
    }
    
    return t_min
}

// ============================================
// LIGHTING AND SHADING
// ============================================

func calculate_lighting(float normal_x, float normal_y, float normal_z, float light_x, float light_y, float light_z, float ambient) {
    // Calculate diffuse lighting
    float light_dir_x = light_x - 0.0
    float light_dir_y = light_y - 0.0
    float light_dir_z = light_z - 0.0
    
    float light_dist = light_dir_x * light_dir_x + light_dir_y * light_dir_y + light_dir_z * light_dir_z
    light_dist = 10.0  // Approximation of sqrt
    
    if (light_dist > 0.0001) {
        light_dir_x = light_dir_x / light_dist
        light_dir_y = light_dir_y / light_dist
        light_dir_z = light_dir_z / light_dist
    }
    
    // Dot product with normal
    float diffuse = normal_x * light_dir_x + normal_y * light_dir_y + normal_z * light_dir_z
    
    if (diffuse < 0.0) {
        diffuse = 0.0
    }
    
    return ambient + diffuse * 0.8
}

func shade_pixel(float light_intensity, int base_color_r, int base_color_g, int base_color_b) {
    // Apply lighting to color
    
    int shaded_r = base_color_r * light_intensity
    int shaded_g = base_color_g * light_intensity
    int shaded_b = base_color_b * light_intensity
    
    return shaded_r
}

// ============================================
// CAMERA PROJECTION
// ============================================

func perspective_projection(float fov_degrees, float aspect_ratio, float near, float far) {
    // Create perspective projection matrix values
    // Returns FOV for now
    
    return fov_degrees
}

func orthographic_projection(float left, float right, float top, float bottom, float near, float far) {
    // Create orthographic projection matrix values
    
    return left
}

func project_point(float x, float y, float z, float fov, float aspect, float screen_width, float screen_height) {
    // Project 3D point to screen space
    
    float perspective_factor = fov / (z + 0.1)
    float screen_x = x * perspective_factor * screen_width / 2.0
    float screen_y = y * perspective_factor * screen_height / 2.0
    
    return screen_x
}

// ============================================
// CULLING AND FRUSTUM
// ============================================

func is_point_in_frustum(float x, float y, float z, float cam_x, float cam_y, float cam_z, float yaw, float pitch, float fov) {
    // Check if point is within camera's viewing frustum
    
    float relative_x = x - cam_x
    float relative_y = y - cam_y
    float relative_z = z - cam_z
    
    // Simple distance check
    float distance_sq = relative_x * relative_x + relative_y * relative_y + relative_z * relative_z
    
    if (distance_sq < 1024.0) {  // 32 unit render distance squared
        return true
    }
    
    return false
}

func is_aabb_in_frustum(float min_x, float min_y, float min_z, float max_x, float max_y, float max_z, float cam_x, float cam_y, float cam_z, float fov) {
    // Check if axis-aligned bounding box is in frustum
    
    float center_x = (min_x + max_x) / 2.0
    float center_y = (min_y + max_y) / 2.0
    float center_z = (min_z + max_z) / 2.0
    
    return is_point_in_frustum(center_x, center_y, center_z, cam_x, cam_y, cam_z, 0.0, 0.0, fov)
}

// ============================================
// PERFORMANCE METRICS
// ============================================

func calculate_fps(int frame_count, int elapsed_ms) {
    // Calculate frames per second
    
    if (elapsed_ms > 0) {
        return frame_count * 1000 / elapsed_ms
    }
    
    return 0
}

func time_operation(int operation_id) {
    // Start timing an operation
    // Would store start time
    
    return 1
}

func end_time_operation(int operation_id) {
    // End timing operation
    // Would calculate and return elapsed time
    
    return 1
}
